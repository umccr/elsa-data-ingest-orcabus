// GENERATED by @gel/generate v0.7.1
// This file is automatically generated from .edgeql query files.
// To make changes, edit the source .edgeql file and regenerate.

import type {Executor} from "gel";

export type AddArtifactFastqPairArgs = {
  readonly "dArtifact": string;
  readonly "id": string;
};

export type AddArtifactFastqPairReturns = {
  "id": string;
} | null;

export function addArtifactFastqPair(client: Executor, args: AddArtifactFastqPairArgs): Promise<AddArtifactFastqPairReturns> {
  return client.querySingle(`\
with
    id := <uuid>$id,
    dArtifact := <lab::ArtifactFastqPair>$dArtifact

update dataset::DatasetSpecimen filter .id = id
set {
    artifacts += dArtifact
}`, args);

}


export type GetPatientArgs = {
  readonly "externalId": string;
};

export type GetPatientReturns = {
  "id": string;
} | null;

export function getPatient(client: Executor, args: GetPatientArgs): Promise<GetPatientReturns> {
  return client.querySingle(`\
with
    externalId := <str>$externalId

select dataset::DatasetPatient filter ("", externalId) in std::array_unpack(.externalIdentifiers) limit 1`, args);

}


export type GetCaseArgs = {
  readonly "externalId": string;
};

export type GetCaseReturns = {
  "id": string;
} | null;

export function getCase(client: Executor, args: GetCaseArgs): Promise<GetCaseReturns> {
  return client.querySingle(`\
with
    externalId := <str>$externalId

select dataset::DatasetCase filter ("", externalId) in std::array_unpack(.externalIdentifiers) limit 1`, args);

}


export type AddSpecimenArgs = {
  readonly "dSpecimen": string;
  readonly "id": string;
};

export type AddSpecimenReturns = {
  "id": string;
} | null;

export function addSpecimen(client: Executor, args: AddSpecimenArgs): Promise<AddSpecimenReturns> {
  return client.querySingle(`\
with
    id := <uuid>$id,
    dSpecimen := <dataset::DatasetSpecimen>$dSpecimen

update dataset::DatasetPatient filter .id = id
set {
    specimens += dSpecimen
}`, args);

}


export type GetSpecimenArgs = {
  readonly "externalId": string;
};

export type GetSpecimenReturns = {
  "id": string;
} | null;

export function getSpecimen(client: Executor, args: GetSpecimenArgs): Promise<GetSpecimenReturns> {
  return client.querySingle(`\
with
    externalId := <str>$externalId

select dataset::DatasetSpecimen filter ("", externalId) in std::array_unpack(.externalIdentifiers) limit 1`, args);

}


export type GetDatasetArgs = {
  readonly "id": string;
};

export type GetDatasetReturns = {
  "description": string;
  "id": string;
  "isInConfig": boolean;
  "totalArtifactFastqPairCount": number;
  "totalCaseCount": number;
  "totalPatientCount": number;
  "totalSpecimenCount": number;
  "uri": string;
  "updatedDateTime": Date | null;
} | null;

export function getDataset(client: Executor, args: GetDatasetArgs): Promise<GetDatasetReturns> {
  return client.querySingle(`\
with
    id := <uuid>$id

select dataset::Dataset {
    id,
    uri,
    description,
    updatedDateTime,
    isInConfig,
    totalCaseCount := count(.cases),
    totalPatientCount := count(.cases.patients),
    totalSpecimenCount := count(.cases.patients.specimens),
    totalArtifactFastqPairCount := count(.cases.patients.specimens.artifacts)
} filter .id = id`, args);

}


export type AddCaseArgs = {
  readonly "dCase": string;
  readonly "id": string;
};

export type AddCaseReturns = {
  "id": string;
} | null;

export function addCase(client: Executor, args: AddCaseArgs): Promise<AddCaseReturns> {
  return client.querySingle(`\
with
    id := <uuid>$id,
    dCase := <dataset::DatasetCase>$dCase

update dataset::Dataset filter .id = id
set {
    cases += dCase
}`, args);

}


export type GetArtifactFastqPairArgs = {
  readonly "forwardFileId": string;
  readonly "reverseFileId": string;
};

export type GetArtifactFastqPairReturns = {
  "id": string;
} | null;

export function getArtifactFastqPair(client: Executor, args: GetArtifactFastqPairArgs): Promise<GetArtifactFastqPairReturns> {
  return client.querySingle(`\
with
    forwardFileId := <uuid>$forwardFileId,
    reverseFileId := <uuid>$reverseFileId

select lab::ArtifactFastqPair filter
    .forwardFile.id = forwardFileId and
    .reverseFile.id = reverseFileId
limit 1`, args);

}


export type InsertArtifactFastqPairArgs = {
  readonly "forwardFile": string;
  readonly "reverseFile": string;
};

export type InsertArtifactFastqPairReturns = {
  "id": string;
};

export function insertArtifactFastqPair(client: Executor, args: InsertArtifactFastqPairArgs): Promise<InsertArtifactFastqPairReturns> {
  return client.queryRequiredSingle(`\
with
    forwardFile := <storage::File>$forwardFile,
    reverseFile := <storage::File>$reverseFile

insert lab::ArtifactFastqPair {
    forwardFile := forwardFile,
    reverseFile := reverseFile
}`, args);

}


export type InsertPatientArgs = {
  readonly "externalIdentifiers": ReadonlyArray<{
  readonly "system": string;
  readonly "value": string;
}>;
  readonly "sexAtBirth": string;
};

export type InsertPatientReturns = {
  "id": string;
};

export function insertPatient(client: Executor, args: InsertPatientArgs): Promise<InsertPatientReturns> {
  return client.queryRequiredSingle(`\
with
    externalIdentifiers := <array<tuple<system: str, value: str>>>$externalIdentifiers,
    sexAtBirth := <str>$sexAtBirth

insert dataset::DatasetPatient {
    externalIdentifiers := externalIdentifiers,
    sexAtBirth := sexAtBirth
}`, args);

}


export type InsertSpecimenArgs = {
  readonly "externalIdentifiers": ReadonlyArray<{
  readonly "system": string;
  readonly "value": string;
}>;
  readonly "sampleType"?: string | null;
};

export type InsertSpecimenReturns = {
  "id": string;
};

export function insertSpecimen(client: Executor, args: InsertSpecimenArgs): Promise<InsertSpecimenReturns> {
  return client.queryRequiredSingle(`\
with
    externalIdentifiers := <array<tuple<system: str, value: str>>>$externalIdentifiers,
    sampleType := <optional str>$sampleType

insert dataset::DatasetSpecimen {
    externalIdentifiers := externalIdentifiers,
    sampleType := sampleType
}`, args);

}


export type InsertCaseArgs = {
  readonly "externalIdentifiers": ReadonlyArray<{
  readonly "system": string;
  readonly "value": string;
}>;
};

export type InsertCaseReturns = {
  "id": string;
};

export function insertCase(client: Executor, args: InsertCaseArgs): Promise<InsertCaseReturns> {
  return client.queryRequiredSingle(`\
with
    externalIdentifiers := <array<tuple<system: str, value: str>>>$externalIdentifiers

insert dataset::DatasetCase {
    externalIdentifiers := externalIdentifiers
}`, args);

}


export type AddPatientArgs = {
  readonly "dPatient": string;
  readonly "id": string;
};

export type AddPatientReturns = {
  "id": string;
} | null;

export function addPatient(client: Executor, args: AddPatientArgs): Promise<AddPatientReturns> {
  return client.querySingle(`\
with
    id := <uuid>$id,
    dPatient := <dataset::DatasetPatient>$dPatient

update dataset::DatasetCase filter .id = id
set {
    # FIXME It seems to me that the current Elsa model exclusivity constraint one Case per Patient.
    # patients += dPatient
    patients := dPatient
}`, args);

}


export type UpsertFileArgs = {
  readonly "checksums": ReadonlyArray<{
  readonly "type": string;
  readonly "value": string;
}>;
  readonly "isDeleted": boolean;
  readonly "size": number;
  readonly "url": string;
};

export type UpsertFileReturns = {
  "id": string;
};

export function upsertFile(client: Executor, args: UpsertFileArgs): Promise<UpsertFileReturns> {
  return client.queryRequiredSingle(`\
with
    url := <str>$url,
    size := <int64>$size,
    checksums := <array<tuple<type: str, value: str>>>$checksums,
    isDeleted := <bool>$isDeleted,

insert storage::File {
    url := url,
    size := size,
    checksums := checksums,
    isDeleted := isDeleted
}
unless conflict on .url else (
    update storage::File set {
        size := size,
        checksums := checksums,
        isDeleted := isDeleted
    }
)`, args);

}


export type GetAllDatasetArgs = {
  readonly "limit"?: number | null;
  readonly "offset"?: number | null;
};

export type GetAllDatasetReturns = {
  "total": number;
  "data": Array<{
    "description": string;
    "isInConfig": boolean;
    "totalCaseCount": number;
    "totalPatientCount": number;
    "totalSpecimenCount": number;
    "uri": string;
    "updatedDateTime": Date | null;
  }>;
};

export function getAllDataset(client: Executor, args: GetAllDatasetArgs): Promise<GetAllDatasetReturns> {
  return client.queryRequiredSingle(`\
# Get all datasets (with pagination) when accessing user is allowed to do so

with

  dataset := (
    select dataset::Dataset
  )

select {
  data := (
    select dataset {
      uri,
      description,
      updatedDateTime,
      isInConfig,
      totalCaseCount := count(.cases),
      totalPatientCount := count(.cases.patients),
      totalSpecimenCount := count(.cases.patients.specimens),
    }
    order by
        .isInConfig desc 
          then 
        .updatedDateTime desc
          then 
        .uri desc
    offset
       <optional int64>$offset
    limit
       <optional int64>$limit
  ),
  total := count(dataset)
}`, args);

}


export type UpsertDatasetArgs = {
  readonly "description": string;
  readonly "externalIdentifiers": ReadonlyArray<{
  readonly "system": string;
  readonly "value": string;
}>;
  readonly "updatedDateTime": Date;
  readonly "uri": string;
};

export type UpsertDatasetReturns = {
  "id": string;
};

export function upsertDataset(client: Executor, args: UpsertDatasetArgs): Promise<UpsertDatasetReturns> {
  return client.queryRequiredSingle(`\
with
    description := <str>$description,
    updatedDateTime := <datetime>$updatedDateTime,
    uri := <str>$uri,
    externalIdentifiers := <array<tuple<system: str, value: str>>>$externalIdentifiers,

insert dataset::Dataset {
    description := description,
    updatedDateTime := updatedDateTime,
    uri := uri,
    externalIdentifiers := externalIdentifiers
}
unless conflict on .uri else (
    update dataset::Dataset set {
        description := description,
        updatedDateTime := updatedDateTime,
        externalIdentifiers := externalIdentifiers
    }
)`, args);

}
